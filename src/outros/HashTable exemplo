Insert and find should be pretty apparent.  Lookup is just like find,
but it raises an exception (see below) when it can't find the key
you gave it.
The tricky thing is mkTable.  Here's an example where I'm using a
hash table to map strings to integers:

open HashTable

(* raised when I do a lookup and can't find something *)
exception Can't_Find_It

(* used to convert a string to a hash code -- i.e., word *)
val hash_fn : string->word = HashString.hashString

(* used to compare keys in the hash table *)
fun cmp_fn : string*string->bool = (op =)

(* initial table size -- need something relatively prime and
* approximately the size of the number of elements you expect
* to be in the hash table.  Note that the implementation resizes
* as needed to avoid major collisions. *)
val initial_size : int = 101

val t : (string,string) table = mkTable (hash_fn, cmp_fn)
(initial_size, Can't_Find_it)

So, I passed in to mkTable (1) a function for converting keys to hash
codes (words), (2) a function for comparing keys (cmp_fn), (3) an
initial size for the table, (3) an exception to raise when the hash
table can't find a key upon lookup.

Now I can insert string*int pairs into my table:

insert t ("Greg",33);
insert t ("Amy",3);
insert t ("John",1);

and I can look them up by key (i.e., string):

lookup t "Greg" (* should evaluate to 33 *)
lookup t "Amy"  (* should evaluate to 3 *)

If I give it a key that's not in the table, then the exception
I passed in to mkTable (Can't_Find_it) will be raised:

lookup t "Raymond" (* should raise Can't_Find_it *)